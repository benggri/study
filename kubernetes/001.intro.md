# kubernetes 

## 개념
- 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼이다.
- 쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다.
- 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다.
- 쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.
- 쿠버네티스란 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어에서 유래했다.
- K8s라는 표기는 "K"와 "s"와 그 사이에 있는 8글자를 나타내는 약식 표기이다.
- 구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화했다.
- 쿠버네티스는 프로덕션 워크로드를 대규모로 운영하는 15년 이상의 구글 경험과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어 있다.

---

## 등장 배경
### 전통적인 배포
- 초기 조직은 애플리케이션을 물리 서버에서 실행했었다.
- 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다.
- 예를 들어 물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스 전부를 차지하는 애플리케이션 인스턴스가 있을 수 있고, 결과적으로는 다른 애플리케이션의 성능이 저하될 수 있었다.
- 이에 대한 해결책으로 서로 다른 여러 물리 서버에서 각 애플리케이션을 실행할 수도 있다.
- 그러나 이는 리소스가 충분히 활용되지 않는다는 점에서 확장 가능하지 않았으며, 조직이 많은 물리 서버를 유지하는 데에 높은 비용이 들었다.
### 가상화된 배포
- 그 해결책으로 가상화가 도입되었다.
- 이는 단일 물리 서버의 CPU에서 여러 가상 시스템 (VM)을 실행할 수 있게 한다.
- 가상화를 사용하면 VM간에 애플리케이션을 격리하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스할 수 없으므로, 일정 수준의 보안성을 제공할 수 있다.
- 가상화를 사용하면 물리 서버에서 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성을 제공한다. 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 만들 수 있다.
- 각 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신이다.
### 컨테이너 개발
  - 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유한다.
  - 그러므로 컨테이너는 가볍다고 여겨진다.
  - VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있다.
  - 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있다.

#### 컨테이너의 특장점
- **기민한 애플리케이션 생성과 배포**: VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적이다.
- **지속적인 개발, 통합 및 배포**: 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 효율적으로 롤백할 수 있다.
- **개발과 운영의 관심사 분리**: 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 분리된다.
- **가시성(observability)**: OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.
- **개발, 테스팅 및 운영 환경에 걸친 일관성**: 랩탑에서도 클라우드에서와 동일하게 구동된다.
- **클라우드 및 OS 배포판 간 이식성**: Ubuntu, RHEL, CoreOS, 온-프레미스, 주요 퍼블릭 클라우드와 어디에서든 구동된다.
- **애플리케이션 중심 관리**: 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아진다.
- **느슨하게 결합되고, 분산되고, 유연하며, 자유로운 마이크로서비스**: 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.
  - **리소스 격리**: 애플리케이션 성능을 예측할 수 있다.
  - **리소스 사용량**: 고효율 고집적.

---

## 쿠버네티스 필요성
- 컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법
- 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다.
- 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?
- 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다.
- 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다. 예를 들어, 쿠버네티스는 시스템의 [카나리아 배포](###-카나리아 배포)를 쉽게 관리할 수 있다.

### 카나리아 배포
- 배포 전략(롤링, 블루/그린, 카나리)
#### 롤링(Rolling)
- 일반적인 배포를 의미
- 단순하게 서버를 구성하여 배포하는 전략
- 구 버전에서 신 버전으로 트래픽을 점진적으로 전환하는 배포
- 관리가 편하지만, 배포 중 한쪽 인스턴스의 수가 감소되므로 서버 처리 용량을 미리 고려
#### 블루 그린(Blue Green)
- **그린(신 버전)** 을 배포하고 일제히 전환하여 모든 연결을 **그린(신 버전)** 을 바라보게 하는 전략
- **블루(구 버전)** , **그린(신 버전)** 서버를 동시에 나한히 구성하여 배포 시점에 트래픽이 일제히 전환된다.
- 빠른 롤백이 가능하고, 운영환경에 영향을 주지 않고 실제 서비스 환경으로 **그린(신 버전)** 테스트가 가능
- 단, 시스템 자원이 두배로 필요하여 비용이 더 많이 발생
#### 카나리(Canary)
- 카나리아는 유독가스에 굉장히 민감한 동물로 석탄 광산에서 유독가스 누출의 위험을 알리는 용도로 사용되어왔다
- 미리 위험을 감지하기 위함
- 카나리 배포는 위험을 빠르게 감지할 수 있는 배포 전략
- 지정한 서버 또는 특정 user에게만 배포했다가 정상적이면 전체를 배포한다
- 서버의 트래픽의 일부를 신 버전으로 분산하여 오류 여부를 확인할 수 있다.
- 이런 전략은 A/B 테스트가 가능하며, 성능 모니터링에 유용하다.
- 트래픽을 분산시킬 때는 라우팅을 랜덤하게 할 수 있고, 사용자로 분류할 수 있다.


---

## 참고 자료
[https://kubernetes.io/](https://kubernetes.io/)
[https://kubernetes.io/ko/docs/concepts/overview/](https://kubernetes.io/ko/docs/concepts/overview/)
